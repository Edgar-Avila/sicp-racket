<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2026-01-30 Fri 21:22 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notes on SICP</title>
<meta name="author" content="stack" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Notes on SICP</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org156a6ed">1. Building Abstractions with Procedures</a>
<ul>
<li><a href="#orgd6e6efc">1.1. The elements of programming</a>
<ul>
<li><a href="#org0631866">1.1.1. The substitution model</a></li>
<li><a href="#org074c95d">1.1.2. Applicative order</a></li>
<li><a href="#org9efa9ae">1.1.3. Normal order</a></li>
</ul>
</li>
<li><a href="#orgc0ce7d3">1.2. Procedures and the processes they generate</a>
<ul>
<li><a href="#orga52ace4">1.2.1. Recursive processes</a></li>
<li><a href="#org16bb263">1.2.2. Iterative processes</a></li>
<li><a href="#org562ac82">1.2.3. Tree Recursion</a></li>
<li><a href="#org30adf16">1.2.4. Orders of Growth</a></li>
</ul>
</li>
<li><a href="#org2e6181c">1.3. Formulating abstractions with higher-order procedures</a>
<ul>
<li><a href="#org1f47a81">1.3.1. Procedures as arguments</a></li>
<li><a href="#orge64a142">1.3.2. Procedures using lambda</a></li>
<li><a href="#org7bb1781">1.3.3. Using let to create local variables</a></li>
<li><a href="#orgbd8c5e3">1.3.4. Finding roots of equations by the half-interfal method</a></li>
<li><a href="#orgcf47a4d">1.3.5. Finding fixed points of functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org156a6ed" class="outline-2">
<h2 id="org156a6ed"><span class="section-number-2">1.</span> Building Abstractions with Procedures</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgd6e6efc" class="outline-3">
<h3 id="orgd6e6efc"><span class="section-number-3">1.1.</span> The elements of programming</h3>
<div class="outline-text-3" id="text-1-1">
<p>
We can combine simple ideas into a complex one using this:
</p>
<ul class="org-ul">
<li>Primitive expressions: Simplest entities the language is concerned with</li>
<li>Means of combination: Compound elements built from simpler ones</li>
<li>Means of abstraction: How compound elements can be named and manipulated as units</li>
</ul>
</div>
<div id="outline-container-org0631866" class="outline-4">
<h4 id="org0631866"><span class="section-number-4">1.1.1.</span> The substitution model</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
The interpreter evaluates the element of the combination and applies
the procedure to the arguments. We can do this by two means. Assuming
the following procedures.
</p>
<div class="org-src-container">
<pre class="src src-racket">(define (square a) (* a a))
(define (sum-of-squares a b) (+ (square a) (square b)))
(define (f a) (sum-of-squares (+ a 1) (* a 2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-org074c95d" class="outline-4">
<h4 id="org074c95d"><span class="section-number-4">1.1.2.</span> Applicative order</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
Evaluate the arguments then apply, the method the interpreter
actually uses.
</p>
<div class="org-src-container">
<pre class="src src-racket">;; When we evaluate
(f 5)
;; The reductions are as follows
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square 6) (square 10))
(+ (* 6 6) (* 10 10))
(+ 36 100)
136
</pre>
</div>
</div>
</div>
<div id="outline-container-org9efa9ae" class="outline-4">
<h4 id="org9efa9ae"><span class="section-number-4">1.1.3.</span> Normal order</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
Fully expand then reduce, an alternative method.
</p>
<div class="org-src-container">
<pre class="src src-racket">;; When we evaluate
(f 5)
;; We expand everything
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1)) (square (* 5 2)))
(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
;; Then reduce
(+ (* 6 6) (* 10 10))
(+ 36 100)
136
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc0ce7d3" class="outline-3">
<h3 id="orgc0ce7d3"><span class="section-number-3">1.2.</span> Procedures and the processes they generate</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orga52ace4" class="outline-4">
<h4 id="orga52ace4"><span class="section-number-4">1.2.1.</span> Recursive processes</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Consider:
</p>
<div class="org-src-container">
<pre class="src src-racket">(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (n-1)))))
</pre>
</div>
<p>
If we apply the substitution model we end up with:
</p>
<div class="org-src-container">
<pre class="src src-racket">(factorial 4)
(* 4 (factorial 3))
(* 4 (* 3 (factorial 2)))
(* 4 (* 3 (* 2 (factorial 1))))
(* 4 (* 3 (* 2 1)))
(* 4 (* 3 2))
(* 4 6)
</pre>
</div>
<p>
We can observe the process expands and reduces as it's evaluating the
expressions, the state is held within the chain of deferred
operations, this is a <i>recursive process</i>, since the number of
expansions and reductions grows linearly with n, this is called a
<i>linear recursive process</i>.
</p>
</div>
</div>
<div id="outline-container-org16bb263" class="outline-4">
<h4 id="org16bb263"><span class="section-number-4">1.2.2.</span> Iterative processes</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Now consider the following:
</p>
<div class="org-src-container">
<pre class="src src-racket">(define (factorial n)
  (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (&gt; counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count))
</pre>
</div>
<p>
It grows like so:
</p>
<div class="org-src-container">
<pre class="src src-racket">(factorial 4)
(fact-iter 1 1 4)
(fact-iter 1 2 4)
(fact-iter 2 3 4)
(fact-iter 6 4 4)
(fact-iter 24 5 4)
24
</pre>
</div>
<p>
This does not grow and shrink, all the state is contained within the
arguments to the procedures, we could stop and resume the chain at any
point in time if we count with the right arguments to pass to the
parameters.
</p>
</div>
</div>
<div id="outline-container-org562ac82" class="outline-4">
<h4 id="org562ac82"><span class="section-number-4">1.2.3.</span> Tree Recursion</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
Consider:
</p>
<div class="org-src-container">
<pre class="src src-racket">(define (fib n)
  (cond ((=n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
</pre>
</div>
<p>
It evolves like this
</p>
<div class="org-src-container">
<pre class="src src-racket">                               (fib 4)
                (+ (fib 3)               (fib 2))
        (+ (+ (fib 2) (fib 1))     (+ (fib 1) (fib 0)))
(+ (+ (+ (fib 1) (fib 0)) (fib 1)) (+ (fib 1) (fib 0)))
(+ (+ (+    1       0   )    1   ) (+    1       0))

</pre>
</div>
<p>
The process evolves into a tree of calls to different procedures, hence
it's name.
</p>
</div>
</div>
<div id="outline-container-org30adf16" class="outline-4">
<h4 id="org30adf16"><span class="section-number-4">1.2.4.</span> Orders of Growth</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
\(R(n)\) has an order of growth \(
R(n)=\Theta(f(n))
\) if there are positive
constants \(k_1\) and \(k_2\) independent of n such that:
</p>
\begin{equation}
k_1f(n) \le R(n) \le k_2f(n)
\end{equation}

<p>
The order of growth only provides a crude description of the behavior
of the process, a process with \(n^2\) steps and a process with
\(1000n^2\) steps will all have \(theta(n^2)\) order of growth.
</p>
</div>
</div>
</div>

<div id="outline-container-org2e6181c" class="outline-3">
<h3 id="org2e6181c"><span class="section-number-3">1.3.</span> Formulating abstractions with higher-order procedures</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org1f47a81" class="outline-4">
<h4 id="org1f47a81"><span class="section-number-4">1.3.1.</span> Procedures as arguments</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Procedures that manipulate procedures are called higher-order procedures,
they are useful when the same programming pattern is used
with a number of different procedures.
For example, the following can abstract the pattern of "summing"
numbers, and we can use it to create new procedures that
sum cubes, integers, etc.
</p>
<div class="org-src-container">
<pre class="src src-racket">(define (identity (a) a))
(define (square a) (* a a))
(define (cube a) (* a a a))
(define (1+ a) (+ a 1))
(define (sum term a next b)
  (if (&gt; a b)
      0
      (+ (term a)
         (sum term (next a) next b)))
(define (sum-cubes a b)
  (sum cube a 1+ b))
(define (sum-squares a b)
  (sum square a 1+ b))
(define (sum-ints a b)
  (sum identity a 1+ b))
</pre>
</div>
</div>
</div>
<div id="outline-container-orge64a142" class="outline-4">
<h4 id="orge64a142"><span class="section-number-4">1.3.2.</span> Procedures using lambda</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
For trivial procedures, it's often more convenient to directly
specify them without any names, rather than defining them. This
is what lambdas are for, really useful when passing them as
arguments to higher-order procedures.
</p>
<div class="org-src-container">
<pre class="src src-racket">(define (sum-cubes a b)
  (sum (lambda (x) (* x x x)) a 1+ b))
(define (sum-squares a b)
  (sum (lambda (x) (* x x) a 1+ b))
(define (sum-ints a b)
  (sum (lambda (x) x) a 1+ b))
</pre>
</div>
</div>
</div>
<div id="outline-container-org7bb1781" class="outline-4">
<h4 id="org7bb1781"><span class="section-number-4">1.3.3.</span> Using let to create local variables</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
Imagine we wanted to express:
\[f(x,y)=x(1+xy)^2+y(1-y)+(1+xy)(1-y)\]
Which could be also expressed as:
\[a=1+xy\]
\[b=1-y\]
\[f(x,y)=xa^2+yb+ab\]
We could do:
</p>
<div class="org-src-container">
<pre class="src src-racket">(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a))
       (* y b)
       (* a b)))
  (f-helper (+ 1 (* x y))
            (- 1 y)))
</pre>
</div>
<p>
Which binds a and b to the computed values before applying
the rest of the procedure, but it's somewhat inconvenient,
for this, we can use the special form called <i>let</i>.
</p>
<div class="org-src-container">
<pre class="src src-racket">(define (f x y)
  (let ((a (+ 1 (* x y)))
        ( b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbd8c5e3" class="outline-4">
<h4 id="orgbd8c5e3"><span class="section-number-4">1.3.4.</span> Finding roots of equations by the half-interfal method</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
The half-interval method is a technique for finding the roots
of an equation \(f(x)=0\), where \(f\) is a continuous function and
we count with points \(a\) and \(b\) such that \(f(a) < 0 < f(b)\),
we do this by averaging \(a\) and \(b\) many times, reducing
the interval we're searching on each time. (We're basically binary
searching).
</p>
<div class="org-src-container">
<pre class="src src-racket">;; Helper for the tolerance
(define (close-enough? x y)
  (&lt; (abs (- x y)) 0.001))
;; Actual search
(define (search f neg-point pos-point)
  (let ((midpoint (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ((test-value (f midpoint)))
          (cond ((positive? test-value)
                 (search f neg-point midpoint))
                ((negative? test-value)
                 (search f midpoint pos-point))
                (else midpoint))))))
;; Checks if they're actually of opposite signs
;; and picks on which value passed is the negative
;; one and the positive one in order to pass
;; them correctly to search
(define (half-interval-method f a b)
  (let ((a-value (f a))
        (b-value (f b)))
    (cond ((and (negative? a-value) (positive? b-value))
           (search f a b))
          ((and (negative? b-value) (positive? a-value))
           (search f b a))
          (else
           (error "Valeus are not of opposite sign" a b)))))
;; We can then use it to approximate pi
;; (pi is the point where sin(x) = 0)
(half-interval-method sin 2.0 4.0) ;; 3.14111328125
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcf47a4d" class="outline-4">
<h4 id="orgcf47a4d"><span class="section-number-4">1.3.5.</span> Finding fixed points of functions</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
A number \(x\) is the <i>fixed point</i> of a function if \(f(x) = x\), for
some functions we can find this with an initial guess and applying \(f\)
repeatedly until the value does not change very much (a tolerance)
\[f(x), f(f(x)), f(f(f(x))), ...,\]
</p>
<div class="org-src-container">
<pre class="src src-racket">(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (&lt; (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
;; Trying it on cos
(fixed-point cos 1.0)
;; We can even define a sqrt function in terms of this
(define (sqrt x)
  (fixed-point (lambda (y) (average y (/ x y)))
               1.0))
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: stack</p>
<p class="date">Created: 2026-01-30 Fri 21:22</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
